# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import ccxt.async_support
import hashlib
import math
from ccxt.async_support.base.ws.client import Client
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError


class cube(ccxt.async_support.cube):

    def describe(self):
        return self.deep_extend(super(cube, self).describe(), {
            'has': {
                'ws': True,
                'watchBalance': False,
                'watchMyTrades': True,
                'watchOHLCV': True,
                'watchOrderBook': True,
                'watchOrders': True,
                'watchTicker': True,
                'watchTickers': False,  # for now
                'watchTrades': True,
                'watchPosition': False,
            },
            'urls': {
                'api': {
                    'ws': {
                        'trade': 'wss://api.cube.exchange/os',
                        # wss://api.cube.exchange/md/book/:marketid
                        'marketData': 'wss://api.cube.exchange/md/book/',
                    },
                },
                'test': {
                    'ws': {
                        'trade': 'wss://dev.cube.exchange/os',
                        # wss://dev.cube.exchange/md/book/:marketid
                        'marketData': 'wss://dev.cube.exchange/md/book/',
                    },
                },
            },
            'options': {
            },
            'streaming': {},
            'exceptions': {
                'ws': {
                    'exact': {
                    },
                },
            },
        })

    def on_connected(self, client: Client, message=None):
        # for user hooks
        # ---
        # send heartbeat every 29 seconds to keep ws alive
        intervalMs = 29000
        while(client.isConnected):
            MdMessage, Heartbeat = (lambda MdMessage, Heartbeat: (MdMessage, Heartbeat))(**md)
            # define heartbeat prior to mdMessage instantiation to avoid python error
            # ruff returns Unexpected Token 'Heartbeat' when done inline
            hb = Heartbeat({
                # random number between 1 and 100k, server will respond w it upon receipt
                'requestId': int(math.floor((Math.random()) * 100000) + 1),
                # current unix timestamp
                'timestamp': Date.now() / 1000,
            })
            heartbeatMessage = MdMessage({
                'heartbeat': hb,
            })
            client.send(heartbeatMessage.serializeBinary())
            sleep(intervalMs)

    def get_current_unix_epoch(self) -> bigint:
        now = Date.now()
        secondsSinceEpoch = int(math.floor(now / 1000))
        return BigInt(secondsSinceEpoch)

    def to_little_endian64_bit_number(self, n: bigint) -> bigint:
        lower32Bits = n % BigInt(2 ** 32)
        upper32Bits = (n - lower32Bits) / BigInt(2 ** 32)
        return lower32Bits + (upper32Bits * BigInt(2 ** 32))

    async def authenticate(self, url, params={}):
        self.check_required_credentials()
        accessKeyId = self.apiKey
        timestamp = self.to_little_endian64_bit_number(self.get_current_unix_epoch())
        msg = 'cube.xyz'
        msg = msg + timestamp.toString
        messageHash = self.hmac(self.encode(msg), self.encode(self.secret), hashlib.sha256)
        client = self.client(url)
        future = client.future(messageHash)
        authenticated = self.safe_value(client.subscriptions, messageHash)
        if authenticated is None:
            request = {
                accessKeyId,
                messageHash,
                timestamp,
            }
            self.watch(url, messageHash, request, messageHash, future)
        return future

    def handle_error_message(self, client: Client, message):
        #
        #    {
        #        T: 'error',
        #        code: 400,
        #        msg: 'invalid syntax'
        #    }
        #
        code = self.safe_string(message, 'code')
        msg = self.safe_value(message, 'msg', {})
        raise ExchangeError(self.id + ' code: ' + code + ' message: ' + msg)

    def handle_connected(self, client: Client, message):
        #
        #    {
        #        T: 'success',
        #        msg: 'connected'
        #    }
        #
        return message

    def handle_market_data_message(self, client: Client, message):
        for i in range(0, len(message)):
            data = message[i]
            T = self.safe_string(data, 'T')
            msg = self.safe_value(data, 'msg', {})
            if T == 'subscription':
                return self.handle_subscription(client, data)
            if T == 'success' and msg == 'connected':
                return self.handle_connected(client, data)
            if T == 'success' and msg == 'authenticated':
                return self.handle_authenticate(client, data)
            methods = {
                'error': self.handle_error_message,
                # 'b': self.handleOHLCV,
                # 'q': self.handleTicker,
                # 't': self.handleTrades,
                # 'o': self.handleOrderBook,
            }
            method = self.safe_value(methods, T)
            if method is not None:
                method(client, data)

    def handle_trade_message(self, client: Client, message):
        stream = self.safe_string(message, 'stream')
        methods = {
            'authorization': self.handle_authenticate,
            'listening': self.handle_subscription,
            # 'trade_updates': self.handleTradeUpdate,
        }
        method = self.safe_value(methods, stream)
        if method is not None:
            method(client, message)

    def handle_message(self, client: Client, message):
        if isinstance(message, list):
            return self.handle_market_data_message(client, message)
        self.handle_trade_message(client, message)

    def handle_authenticate(self, client: Client, message):
        #
        # crypto
        #    {
        #        T: 'success',
        #        msg: 'connected'
        #    ]
        #
        # trading
        #    {
        #        "stream": "authorization",
        #        "data": {
        #            "status": "authorized",
        #            "action": "authenticate"
        #        }
        #    }
        # error
        #    {
        #        stream: 'authorization',
        #        data: {
        #            action: 'authenticate',
        #            message: 'access key verification failed',
        #            status: 'unauthorized'
        #        }
        #    }
        #
        T = self.safe_string(message, 'T')
        data = self.safe_value(message, 'data', {})
        status = self.safe_string(data, 'status')
        if T == 'success' or status == 'authorized':
            promise = client.futures['authenticated']
            promise.resolve(message)
            return
        raise AuthenticationError(self.id + ' failed to authenticate.')

    def handle_subscription(self, client: Client, message):
        return message
