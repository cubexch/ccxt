<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\AuthenticationError;

class cube extends \ccxt\async\cube {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => false,
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchOrderBook' => true,
                'watchOrders' => true,
                'watchTicker' => true,
                'watchTickers' => false, // for now
                'watchTrades' => true,
                'watchPosition' => false,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'trade' => 'wss://api.cube.exchange/os',
                        // wss://api.cube.exchange/md/book/:marketid
                        'marketData' => 'wss://api.cube.exchange/md/book/',
                    ),
                ),
                'test' => array(
                    'ws' => array(
                        'trade' => 'wss://dev.cube.exchange/os',
                        // wss://dev.cube.exchange/md/book/:marketid
                        'marketData' => 'wss://dev.cube.exchange/md/book/',
                    ),
                ),
            ),
            'options' => array(
            ),
            'streaming' => array(),
            'exceptions' => array(
                'ws' => array(
                    'exact' => array(
                    ),
                ),
            ),
        ));
    }

    public function on_connected(Client $client, $message = null) {
        // for user hooks
        // ---
        // send heartbeat every 29 seconds to keep ws alive
        $intervalMs = 29000;
        while ($client->isConnected) {
            array( MdMessage, Heartbeat ) = md;
            // define heartbeat prior to mdMessage instantiation to avoid python error
            // ruff returns Unexpected Token 'Heartbeat' when done inline
            $hb = new Heartbeat (array(
                // random number between 1 and 100k, server will respond w it upon receipt
                'requestId' => (int) floor((Math.random () * 100000) + 1),
                // current unix timestamp
                'timestamp' => Date.now () / 1000,
            ));
            $heartbeatMessage = new MdMessage (array(
                'heartbeat' => $hb,
            ));
            $client->send ($heartbeatMessage->serializeBinary ());
            sleep ($intervalMs);
        }
    }

    public function get_current_unix_epoch(): bigint {
        $now = Date.now ();
        $secondsSinceEpoch = (int) floor($now / 1000);
        return BigInt ($secondsSinceEpoch);
    }

    public function to_little_endian64_bit_number(bigint $n): bigint {
        $lower32Bits = fmod($n, BigInt) (2 ** 32);
        $upper32Bits = ($n - $lower32Bits) / BigInt (2 ** 32);
        return $lower32Bits . ($upper32Bits * BigInt (2 ** 32));
    }

    public function authenticate($url, $params = array ()) {
        $this->check_required_credentials();
        $accessKeyId = $this->apiKey;
        $timestamp = $this->to_little_endian64_bit_number($this->get_current_unix_epoch());
        $msg = 'cube.xyz';
        $msg = $msg . $timestamp->toString;
        $messageHash = $this->hmac($this->encode($msg), $this->encode($this->secret), 'sha256');
        $client = $this->client($url);
        $future = $client->future ($messageHash);
        $authenticated = $this->safe_value($client->subscriptions, $messageHash);
        if ($authenticated === null) {
            $request = array(
                $accessKeyId,
                $messageHash,
                $timestamp,
            );
            $this->watch($url, $messageHash, $request, $messageHash, $future);
        }
        return $future;
    }

    public function handle_error_message(Client $client, $message) {
        //
        //    {
        //        T => 'error',
        //        $code => 400,
        //        $msg => 'invalid syntax'
        //    }
        //
        $code = $this->safe_string($message, 'code');
        $msg = $this->safe_value($message, 'msg', array());
        throw new ExchangeError($this->id . ' $code => ' . $code . ' $message => ' . $msg);
    }

    public function handle_connected(Client $client, $message) {
        //
        //    {
        //        T => 'success',
        //        msg => 'connected'
        //    }
        //
        return $message;
    }

    public function handle_market_data_message(Client $client, $message) {
        for ($i = 0; $i < count($message); $i++) {
            $data = $message[$i];
            $T = $this->safe_string($data, 'T');
            $msg = $this->safe_value($data, 'msg', array());
            if ($T === 'subscription') {
                return $this->handle_subscription($client, $data);
            }
            if ($T === 'success' && $msg === 'connected') {
                return $this->handle_connected($client, $data);
            }
            if ($T === 'success' && $msg === 'authenticated') {
                return $this->handle_authenticate($client, $data);
            }
            $methods = array(
                'error' => array($this, 'handle_error_message'),
                // 'b' => $this->handleOHLCV,
                // 'q' => $this->handleTicker,
                // 't' => $this->handleTrades,
                // 'o' => $this->handleOrderBook,
            );
            $method = $this->safe_value($methods, $T);
            if ($method !== null) {
                $method($client, $data);
            }
        }
    }

    public function handle_trade_message(Client $client, $message) {
        $stream = $this->safe_string($message, 'stream');
        $methods = array(
            'authorization' => array($this, 'handle_authenticate'),
            'listening' => array($this, 'handle_subscription'),
            // 'trade_updates' => $this->handleTradeUpdate,
        );
        $method = $this->safe_value($methods, $stream);
        if ($method !== null) {
            $method($client, $message);
        }
    }

    public function handle_message(Client $client, $message) {
        if (gettype($message) === 'array' && array_keys($message) === array_keys(array_keys($message))) {
            return $this->handle_market_data_message($client, $message);
        }
        $this->handle_trade_message($client, $message);
    }

    public function handle_authenticate(Client $client, $message) {
        //
        // crypto
        //    {
        //        $T => 'success',
        //        msg => 'connected'
        //    ]
        //
        // trading
        //    {
        //        "stream" => "authorization",
        //        "data" => {
        //            "status" => "authorized",
        //            "action" => "authenticate"
        //        }
        //    }
        // error
        //    {
        //        stream => 'authorization',
        //        $data => {
        //            action => 'authenticate',
        //            $message => 'access key verification failed',
        //            $status => 'unauthorized'
        //        }
        //    }
        //
        $T = $this->safe_string($message, 'T');
        $data = $this->safe_value($message, 'data', array());
        $status = $this->safe_string($data, 'status');
        if ($T === 'success' || $status === 'authorized') {
            $promise = $client->futures['authenticated'];
            $promise->resolve ($message);
            return;
        }
        throw new AuthenticationError($this->id . ' failed to authenticate.');
    }

    public function handle_subscription(Client $client, $message) {
        return $message;
    }
}
