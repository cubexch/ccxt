/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.15.8
 * source: trade.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
 import * as pb_1 from "google-protobuf";
export namespace md {
    export enum Side {
        BID = 0,
        ASK = 1
    }
    export enum KlineInterval {
        S1 = 0,
        M1 = 1,
        M15 = 2,
        H1 = 3,
        H4 = 4,
        D1 = 5
    }
    export enum RateUpdateSide {
        BASE = 0,
        QUOTE = 1
    }
    export class MdMessage extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3, 4, 5, 6, 7, 8]];
        constructor(data?: any[] | ({} & (({
            heartbeat?: Heartbeat;
            summary?: never;
            trades?: never;
            mboSnapshot?: never;
            mboDiff?: never;
            mbpSnapshot?: never;
            mbpDiff?: never;
            kline?: never;
        } | {
            heartbeat?: never;
            summary?: Summary;
            trades?: never;
            mboSnapshot?: never;
            mboDiff?: never;
            mbpSnapshot?: never;
            mbpDiff?: never;
            kline?: never;
        } | {
            heartbeat?: never;
            summary?: never;
            trades?: Trades;
            mboSnapshot?: never;
            mboDiff?: never;
            mbpSnapshot?: never;
            mbpDiff?: never;
            kline?: never;
        } | {
            heartbeat?: never;
            summary?: never;
            trades?: never;
            mboSnapshot?: MarketByOrder;
            mboDiff?: never;
            mbpSnapshot?: never;
            mbpDiff?: never;
            kline?: never;
        } | {
            heartbeat?: never;
            summary?: never;
            trades?: never;
            mboSnapshot?: never;
            mboDiff?: MarketByOrderDiff;
            mbpSnapshot?: never;
            mbpDiff?: never;
            kline?: never;
        } | {
            heartbeat?: never;
            summary?: never;
            trades?: never;
            mboSnapshot?: never;
            mboDiff?: never;
            mbpSnapshot?: MarketByPrice;
            mbpDiff?: never;
            kline?: never;
        } | {
            heartbeat?: never;
            summary?: never;
            trades?: never;
            mboSnapshot?: never;
            mboDiff?: never;
            mbpSnapshot?: never;
            mbpDiff?: MarketByPriceDiff;
            kline?: never;
        } | {
            heartbeat?: never;
            summary?: never;
            trades?: never;
            mboSnapshot?: never;
            mboDiff?: never;
            mbpSnapshot?: never;
            mbpDiff?: never;
            kline?: Kline;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("heartbeat" in data && data.heartbeat != undefined) {
                    this.heartbeat = data.heartbeat;
                }
                if ("summary" in data && data.summary != undefined) {
                    this.summary = data.summary;
                }
                if ("trades" in data && data.trades != undefined) {
                    this.trades = data.trades;
                }
                if ("mboSnapshot" in data && data.mboSnapshot != undefined) {
                    this.mboSnapshot = data.mboSnapshot;
                }
                if ("mboDiff" in data && data.mboDiff != undefined) {
                    this.mboDiff = data.mboDiff;
                }
                if ("mbpSnapshot" in data && data.mbpSnapshot != undefined) {
                    this.mbpSnapshot = data.mbpSnapshot;
                }
                if ("mbpDiff" in data && data.mbpDiff != undefined) {
                    this.mbpDiff = data.mbpDiff;
                }
                if ("kline" in data && data.kline != undefined) {
                    this.kline = data.kline;
                }
            }
        }
        get heartbeat() {
            return pb_1.Message.getWrapperField(this, Heartbeat, 1) as Heartbeat;
        }
        set heartbeat(value: Heartbeat) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_heartbeat() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get summary() {
            return pb_1.Message.getWrapperField(this, Summary, 2) as Summary;
        }
        set summary(value: Summary) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_summary() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get trades() {
            return pb_1.Message.getWrapperField(this, Trades, 3) as Trades;
        }
        set trades(value: Trades) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_trades() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get mboSnapshot() {
            return pb_1.Message.getWrapperField(this, MarketByOrder, 4) as MarketByOrder;
        }
        set mboSnapshot(value: MarketByOrder) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_mboSnapshot() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get mboDiff() {
            return pb_1.Message.getWrapperField(this, MarketByOrderDiff, 5) as MarketByOrderDiff;
        }
        set mboDiff(value: MarketByOrderDiff) {
            pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
        }
        get has_mboDiff() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get mbpSnapshot() {
            return pb_1.Message.getWrapperField(this, MarketByPrice, 6) as MarketByPrice;
        }
        set mbpSnapshot(value: MarketByPrice) {
            pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
        }
        get has_mbpSnapshot() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get mbpDiff() {
            return pb_1.Message.getWrapperField(this, MarketByPriceDiff, 7) as MarketByPriceDiff;
        }
        set mbpDiff(value: MarketByPriceDiff) {
            pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
        }
        get has_mbpDiff() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get kline() {
            return pb_1.Message.getWrapperField(this, Kline, 8) as Kline;
        }
        set kline(value: Kline) {
            pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
        }
        get has_kline() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get inner() {
            const cases: {
                [index: number]: "none" | "heartbeat" | "summary" | "trades" | "mboSnapshot" | "mboDiff" | "mbpSnapshot" | "mbpDiff" | "kline";
            } = {
                0: "none",
                1: "heartbeat",
                2: "summary",
                3: "trades",
                4: "mboSnapshot",
                5: "mboDiff",
                6: "mbpSnapshot",
                7: "mbpDiff",
                8: "kline"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6, 7, 8])];
        }
        static fromObject(data: {
            heartbeat?: ReturnType<typeof Heartbeat.prototype.toObject>;
            summary?: ReturnType<typeof Summary.prototype.toObject>;
            trades?: ReturnType<typeof Trades.prototype.toObject>;
            mboSnapshot?: ReturnType<typeof MarketByOrder.prototype.toObject>;
            mboDiff?: ReturnType<typeof MarketByOrderDiff.prototype.toObject>;
            mbpSnapshot?: ReturnType<typeof MarketByPrice.prototype.toObject>;
            mbpDiff?: ReturnType<typeof MarketByPriceDiff.prototype.toObject>;
            kline?: ReturnType<typeof Kline.prototype.toObject>;
        }): MdMessage {
            const message = new MdMessage({});
            if (data.heartbeat != null) {
                message.heartbeat = Heartbeat.fromObject(data.heartbeat);
            }
            if (data.summary != null) {
                message.summary = Summary.fromObject(data.summary);
            }
            if (data.trades != null) {
                message.trades = Trades.fromObject(data.trades);
            }
            if (data.mboSnapshot != null) {
                message.mboSnapshot = MarketByOrder.fromObject(data.mboSnapshot);
            }
            if (data.mboDiff != null) {
                message.mboDiff = MarketByOrderDiff.fromObject(data.mboDiff);
            }
            if (data.mbpSnapshot != null) {
                message.mbpSnapshot = MarketByPrice.fromObject(data.mbpSnapshot);
            }
            if (data.mbpDiff != null) {
                message.mbpDiff = MarketByPriceDiff.fromObject(data.mbpDiff);
            }
            if (data.kline != null) {
                message.kline = Kline.fromObject(data.kline);
            }
            return message;
        }
        toObject() {
            const data: {
                heartbeat?: ReturnType<typeof Heartbeat.prototype.toObject>;
                summary?: ReturnType<typeof Summary.prototype.toObject>;
                trades?: ReturnType<typeof Trades.prototype.toObject>;
                mboSnapshot?: ReturnType<typeof MarketByOrder.prototype.toObject>;
                mboDiff?: ReturnType<typeof MarketByOrderDiff.prototype.toObject>;
                mbpSnapshot?: ReturnType<typeof MarketByPrice.prototype.toObject>;
                mbpDiff?: ReturnType<typeof MarketByPriceDiff.prototype.toObject>;
                kline?: ReturnType<typeof Kline.prototype.toObject>;
            } = {};
            if (this.heartbeat != null) {
                data.heartbeat = this.heartbeat.toObject();
            }
            if (this.summary != null) {
                data.summary = this.summary.toObject();
            }
            if (this.trades != null) {
                data.trades = this.trades.toObject();
            }
            if (this.mboSnapshot != null) {
                data.mboSnapshot = this.mboSnapshot.toObject();
            }
            if (this.mboDiff != null) {
                data.mboDiff = this.mboDiff.toObject();
            }
            if (this.mbpSnapshot != null) {
                data.mbpSnapshot = this.mbpSnapshot.toObject();
            }
            if (this.mbpDiff != null) {
                data.mbpDiff = this.mbpDiff.toObject();
            }
            if (this.kline != null) {
                data.kline = this.kline.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_heartbeat)
                writer.writeMessage(1, this.heartbeat, () => this.heartbeat.serialize(writer));
            if (this.has_summary)
                writer.writeMessage(2, this.summary, () => this.summary.serialize(writer));
            if (this.has_trades)
                writer.writeMessage(3, this.trades, () => this.trades.serialize(writer));
            if (this.has_mboSnapshot)
                writer.writeMessage(4, this.mboSnapshot, () => this.mboSnapshot.serialize(writer));
            if (this.has_mboDiff)
                writer.writeMessage(5, this.mboDiff, () => this.mboDiff.serialize(writer));
            if (this.has_mbpSnapshot)
                writer.writeMessage(6, this.mbpSnapshot, () => this.mbpSnapshot.serialize(writer));
            if (this.has_mbpDiff)
                writer.writeMessage(7, this.mbpDiff, () => this.mbpDiff.serialize(writer));
            if (this.has_kline)
                writer.writeMessage(8, this.kline, () => this.kline.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MdMessage {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MdMessage();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.heartbeat, () => message.heartbeat = Heartbeat.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.summary, () => message.summary = Summary.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.trades, () => message.trades = Trades.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.mboSnapshot, () => message.mboSnapshot = MarketByOrder.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.mboDiff, () => message.mboDiff = MarketByOrderDiff.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.mbpSnapshot, () => message.mbpSnapshot = MarketByPrice.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.mbpDiff, () => message.mbpDiff = MarketByPriceDiff.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.kline, () => message.kline = Kline.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MdMessage {
            return MdMessage.deserialize(bytes);
        }
    }
    export class MarketByPrice extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            levels?: MarketByPrice.Level[];
            chunk?: number;
            numChunks?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("levels" in data && data.levels != undefined) {
                    this.levels = data.levels;
                }
                if ("chunk" in data && data.chunk != undefined) {
                    this.chunk = data.chunk;
                }
                if ("numChunks" in data && data.numChunks != undefined) {
                    this.numChunks = data.numChunks;
                }
            }
        }
        get levels() {
            return pb_1.Message.getRepeatedWrapperField(this, MarketByPrice.Level, 1) as MarketByPrice.Level[];
        }
        set levels(value: MarketByPrice.Level[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get chunk() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set chunk(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get numChunks() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set numChunks(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            levels?: ReturnType<typeof MarketByPrice.Level.prototype.toObject>[];
            chunk?: number;
            numChunks?: number;
        }): MarketByPrice {
            const message = new MarketByPrice({});
            if (data.levels != null) {
                message.levels = data.levels.map(item => MarketByPrice.Level.fromObject(item));
            }
            if (data.chunk != null) {
                message.chunk = data.chunk;
            }
            if (data.numChunks != null) {
                message.numChunks = data.numChunks;
            }
            return message;
        }
        toObject() {
            const data: {
                levels?: ReturnType<typeof MarketByPrice.Level.prototype.toObject>[];
                chunk?: number;
                numChunks?: number;
            } = {};
            if (this.levels != null) {
                data.levels = this.levels.map((item: MarketByPrice.Level) => item.toObject());
            }
            if (this.chunk != null) {
                data.chunk = this.chunk;
            }
            if (this.numChunks != null) {
                data.numChunks = this.numChunks;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.levels.length)
                writer.writeRepeatedMessage(1, this.levels, (item: MarketByPrice.Level) => item.serialize(writer));
            if (this.chunk != 0)
                writer.writeUint32(2, this.chunk);
            if (this.numChunks != 0)
                writer.writeUint32(3, this.numChunks);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MarketByPrice {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MarketByPrice();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.levels, () => pb_1.Message.addToRepeatedWrapperField(message, 1, MarketByPrice.Level.deserialize(reader), MarketByPrice.Level));
                        break;
                    case 2:
                        message.chunk = reader.readUint32();
                        break;
                    case 3:
                        message.numChunks = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MarketByPrice {
            return MarketByPrice.deserialize(bytes);
        }
    }
    export namespace MarketByPrice {
        export class Level extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                price?: number;
                quantity?: number;
                side?: Side;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("price" in data && data.price != undefined) {
                        this.price = data.price;
                    }
                    if ("quantity" in data && data.quantity != undefined) {
                        this.quantity = data.quantity;
                    }
                    if ("side" in data && data.side != undefined) {
                        this.side = data.side;
                    }
                }
            }
            get price() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set price(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get quantity() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set quantity(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get side() {
                return pb_1.Message.getFieldWithDefault(this, 3, Side.BID) as Side;
            }
            set side(value: Side) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                price?: number;
                quantity?: number;
                side?: Side;
            }): Level {
                const message = new Level({});
                if (data.price != null) {
                    message.price = data.price;
                }
                if (data.quantity != null) {
                    message.quantity = data.quantity;
                }
                if (data.side != null) {
                    message.side = data.side;
                }
                return message;
            }
            toObject() {
                const data: {
                    price?: number;
                    quantity?: number;
                    side?: Side;
                } = {};
                if (this.price != null) {
                    data.price = this.price;
                }
                if (this.quantity != null) {
                    data.quantity = this.quantity;
                }
                if (this.side != null) {
                    data.side = this.side;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.price != 0)
                    writer.writeUint64(1, this.price);
                if (this.quantity != 0)
                    writer.writeUint64(2, this.quantity);
                if (this.side != Side.BID)
                    writer.writeEnum(3, this.side);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Level {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Level();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.price = reader.readUint64();
                            break;
                        case 2:
                            message.quantity = reader.readUint64();
                            break;
                        case 3:
                            message.side = reader.readEnum();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Level {
                return Level.deserialize(bytes);
            }
        }
    }
    export class MarketByPriceDiff extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            diffs?: MarketByPriceDiff.Diff[];
            totalBidLevels?: number;
            totalAskLevels?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("diffs" in data && data.diffs != undefined) {
                    this.diffs = data.diffs;
                }
                if ("totalBidLevels" in data && data.totalBidLevels != undefined) {
                    this.totalBidLevels = data.totalBidLevels;
                }
                if ("totalAskLevels" in data && data.totalAskLevels != undefined) {
                    this.totalAskLevels = data.totalAskLevels;
                }
            }
        }
        get diffs() {
            return pb_1.Message.getRepeatedWrapperField(this, MarketByPriceDiff.Diff, 1) as MarketByPriceDiff.Diff[];
        }
        set diffs(value: MarketByPriceDiff.Diff[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get totalBidLevels() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set totalBidLevels(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get totalAskLevels() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set totalAskLevels(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            diffs?: ReturnType<typeof MarketByPriceDiff.Diff.prototype.toObject>[];
            totalBidLevels?: number;
            totalAskLevels?: number;
        }): MarketByPriceDiff {
            const message = new MarketByPriceDiff({});
            if (data.diffs != null) {
                message.diffs = data.diffs.map(item => MarketByPriceDiff.Diff.fromObject(item));
            }
            if (data.totalBidLevels != null) {
                message.totalBidLevels = data.totalBidLevels;
            }
            if (data.totalAskLevels != null) {
                message.totalAskLevels = data.totalAskLevels;
            }
            return message;
        }
        toObject() {
            const data: {
                diffs?: ReturnType<typeof MarketByPriceDiff.Diff.prototype.toObject>[];
                totalBidLevels?: number;
                totalAskLevels?: number;
            } = {};
            if (this.diffs != null) {
                data.diffs = this.diffs.map((item: MarketByPriceDiff.Diff) => item.toObject());
            }
            if (this.totalBidLevels != null) {
                data.totalBidLevels = this.totalBidLevels;
            }
            if (this.totalAskLevels != null) {
                data.totalAskLevels = this.totalAskLevels;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.diffs.length)
                writer.writeRepeatedMessage(1, this.diffs, (item: MarketByPriceDiff.Diff) => item.serialize(writer));
            if (this.totalBidLevels != 0)
                writer.writeUint32(2, this.totalBidLevels);
            if (this.totalAskLevels != 0)
                writer.writeUint32(3, this.totalAskLevels);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MarketByPriceDiff {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MarketByPriceDiff();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.diffs, () => pb_1.Message.addToRepeatedWrapperField(message, 1, MarketByPriceDiff.Diff.deserialize(reader), MarketByPriceDiff.Diff));
                        break;
                    case 2:
                        message.totalBidLevels = reader.readUint32();
                        break;
                    case 3:
                        message.totalAskLevels = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MarketByPriceDiff {
            return MarketByPriceDiff.deserialize(bytes);
        }
    }
    export namespace MarketByPriceDiff {
        export enum DiffOp {
            ADD = 0,
            REMOVE = 1,
            REPLACE = 2
        }
        export class Diff extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                price?: number;
                quantity?: number;
                side?: Side;
                op?: MarketByPriceDiff.DiffOp;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("price" in data && data.price != undefined) {
                        this.price = data.price;
                    }
                    if ("quantity" in data && data.quantity != undefined) {
                        this.quantity = data.quantity;
                    }
                    if ("side" in data && data.side != undefined) {
                        this.side = data.side;
                    }
                    if ("op" in data && data.op != undefined) {
                        this.op = data.op;
                    }
                }
            }
            get price() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set price(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get quantity() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set quantity(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get side() {
                return pb_1.Message.getFieldWithDefault(this, 3, Side.BID) as Side;
            }
            set side(value: Side) {
                pb_1.Message.setField(this, 3, value);
            }
            get op() {
                return pb_1.Message.getFieldWithDefault(this, 4, MarketByPriceDiff.DiffOp.ADD) as MarketByPriceDiff.DiffOp;
            }
            set op(value: MarketByPriceDiff.DiffOp) {
                pb_1.Message.setField(this, 4, value);
            }
            static fromObject(data: {
                price?: number;
                quantity?: number;
                side?: Side;
                op?: MarketByPriceDiff.DiffOp;
            }): Diff {
                const message = new Diff({});
                if (data.price != null) {
                    message.price = data.price;
                }
                if (data.quantity != null) {
                    message.quantity = data.quantity;
                }
                if (data.side != null) {
                    message.side = data.side;
                }
                if (data.op != null) {
                    message.op = data.op;
                }
                return message;
            }
            toObject() {
                const data: {
                    price?: number;
                    quantity?: number;
                    side?: Side;
                    op?: MarketByPriceDiff.DiffOp;
                } = {};
                if (this.price != null) {
                    data.price = this.price;
                }
                if (this.quantity != null) {
                    data.quantity = this.quantity;
                }
                if (this.side != null) {
                    data.side = this.side;
                }
                if (this.op != null) {
                    data.op = this.op;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.price != 0)
                    writer.writeUint64(1, this.price);
                if (this.quantity != 0)
                    writer.writeUint64(2, this.quantity);
                if (this.side != Side.BID)
                    writer.writeEnum(3, this.side);
                if (this.op != MarketByPriceDiff.DiffOp.ADD)
                    writer.writeEnum(4, this.op);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Diff {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Diff();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.price = reader.readUint64();
                            break;
                        case 2:
                            message.quantity = reader.readUint64();
                            break;
                        case 3:
                            message.side = reader.readEnum();
                            break;
                        case 4:
                            message.op = reader.readEnum();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Diff {
                return Diff.deserialize(bytes);
            }
        }
    }
    export class MarketByOrder extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            orders?: MarketByOrder.Order[];
            chunk?: number;
            numChunks?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("orders" in data && data.orders != undefined) {
                    this.orders = data.orders;
                }
                if ("chunk" in data && data.chunk != undefined) {
                    this.chunk = data.chunk;
                }
                if ("numChunks" in data && data.numChunks != undefined) {
                    this.numChunks = data.numChunks;
                }
            }
        }
        get orders() {
            return pb_1.Message.getRepeatedWrapperField(this, MarketByOrder.Order, 1) as MarketByOrder.Order[];
        }
        set orders(value: MarketByOrder.Order[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get chunk() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set chunk(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get numChunks() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set numChunks(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            orders?: ReturnType<typeof MarketByOrder.Order.prototype.toObject>[];
            chunk?: number;
            numChunks?: number;
        }): MarketByOrder {
            const message = new MarketByOrder({});
            if (data.orders != null) {
                message.orders = data.orders.map(item => MarketByOrder.Order.fromObject(item));
            }
            if (data.chunk != null) {
                message.chunk = data.chunk;
            }
            if (data.numChunks != null) {
                message.numChunks = data.numChunks;
            }
            return message;
        }
        toObject() {
            const data: {
                orders?: ReturnType<typeof MarketByOrder.Order.prototype.toObject>[];
                chunk?: number;
                numChunks?: number;
            } = {};
            if (this.orders != null) {
                data.orders = this.orders.map((item: MarketByOrder.Order) => item.toObject());
            }
            if (this.chunk != null) {
                data.chunk = this.chunk;
            }
            if (this.numChunks != null) {
                data.numChunks = this.numChunks;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.orders.length)
                writer.writeRepeatedMessage(1, this.orders, (item: MarketByOrder.Order) => item.serialize(writer));
            if (this.chunk != 0)
                writer.writeUint32(2, this.chunk);
            if (this.numChunks != 0)
                writer.writeUint32(3, this.numChunks);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MarketByOrder {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MarketByOrder();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.orders, () => pb_1.Message.addToRepeatedWrapperField(message, 1, MarketByOrder.Order.deserialize(reader), MarketByOrder.Order));
                        break;
                    case 2:
                        message.chunk = reader.readUint32();
                        break;
                    case 3:
                        message.numChunks = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MarketByOrder {
            return MarketByOrder.deserialize(bytes);
        }
    }
    export namespace MarketByOrder {
        export class Order extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                price?: number;
                quantity?: number;
                exchangeOrderId?: number;
                side?: Side;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("price" in data && data.price != undefined) {
                        this.price = data.price;
                    }
                    if ("quantity" in data && data.quantity != undefined) {
                        this.quantity = data.quantity;
                    }
                    if ("exchangeOrderId" in data && data.exchangeOrderId != undefined) {
                        this.exchangeOrderId = data.exchangeOrderId;
                    }
                    if ("side" in data && data.side != undefined) {
                        this.side = data.side;
                    }
                }
            }
            get price() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set price(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get quantity() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set quantity(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get exchangeOrderId() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set exchangeOrderId(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            get side() {
                return pb_1.Message.getFieldWithDefault(this, 4, Side.BID) as Side;
            }
            set side(value: Side) {
                pb_1.Message.setField(this, 4, value);
            }
            static fromObject(data: {
                price?: number;
                quantity?: number;
                exchangeOrderId?: number;
                side?: Side;
            }): Order {
                const message = new Order({});
                if (data.price != null) {
                    message.price = data.price;
                }
                if (data.quantity != null) {
                    message.quantity = data.quantity;
                }
                if (data.exchangeOrderId != null) {
                    message.exchangeOrderId = data.exchangeOrderId;
                }
                if (data.side != null) {
                    message.side = data.side;
                }
                return message;
            }
            toObject() {
                const data: {
                    price?: number;
                    quantity?: number;
                    exchangeOrderId?: number;
                    side?: Side;
                } = {};
                if (this.price != null) {
                    data.price = this.price;
                }
                if (this.quantity != null) {
                    data.quantity = this.quantity;
                }
                if (this.exchangeOrderId != null) {
                    data.exchangeOrderId = this.exchangeOrderId;
                }
                if (this.side != null) {
                    data.side = this.side;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.price != 0)
                    writer.writeUint64(1, this.price);
                if (this.quantity != 0)
                    writer.writeUint64(2, this.quantity);
                if (this.exchangeOrderId != 0)
                    writer.writeUint64(3, this.exchangeOrderId);
                if (this.side != Side.BID)
                    writer.writeEnum(4, this.side);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Order {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Order();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.price = reader.readUint64();
                            break;
                        case 2:
                            message.quantity = reader.readUint64();
                            break;
                        case 3:
                            message.exchangeOrderId = reader.readUint64();
                            break;
                        case 4:
                            message.side = reader.readEnum();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Order {
                return Order.deserialize(bytes);
            }
        }
    }
    export class MarketByOrderDiff extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            diffs?: MarketByOrderDiff.Diff[];
            totalBidLevels?: number;
            totalAskLevels?: number;
            totalBidOrders?: number;
            totalAskOrders?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("diffs" in data && data.diffs != undefined) {
                    this.diffs = data.diffs;
                }
                if ("totalBidLevels" in data && data.totalBidLevels != undefined) {
                    this.totalBidLevels = data.totalBidLevels;
                }
                if ("totalAskLevels" in data && data.totalAskLevels != undefined) {
                    this.totalAskLevels = data.totalAskLevels;
                }
                if ("totalBidOrders" in data && data.totalBidOrders != undefined) {
                    this.totalBidOrders = data.totalBidOrders;
                }
                if ("totalAskOrders" in data && data.totalAskOrders != undefined) {
                    this.totalAskOrders = data.totalAskOrders;
                }
            }
        }
        get diffs() {
            return pb_1.Message.getRepeatedWrapperField(this, MarketByOrderDiff.Diff, 1) as MarketByOrderDiff.Diff[];
        }
        set diffs(value: MarketByOrderDiff.Diff[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get totalBidLevels() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set totalBidLevels(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get totalAskLevels() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set totalAskLevels(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get totalBidOrders() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set totalBidOrders(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get totalAskOrders() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set totalAskOrders(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            diffs?: ReturnType<typeof MarketByOrderDiff.Diff.prototype.toObject>[];
            totalBidLevels?: number;
            totalAskLevels?: number;
            totalBidOrders?: number;
            totalAskOrders?: number;
        }): MarketByOrderDiff {
            const message = new MarketByOrderDiff({});
            if (data.diffs != null) {
                message.diffs = data.diffs.map(item => MarketByOrderDiff.Diff.fromObject(item));
            }
            if (data.totalBidLevels != null) {
                message.totalBidLevels = data.totalBidLevels;
            }
            if (data.totalAskLevels != null) {
                message.totalAskLevels = data.totalAskLevels;
            }
            if (data.totalBidOrders != null) {
                message.totalBidOrders = data.totalBidOrders;
            }
            if (data.totalAskOrders != null) {
                message.totalAskOrders = data.totalAskOrders;
            }
            return message;
        }
        toObject() {
            const data: {
                diffs?: ReturnType<typeof MarketByOrderDiff.Diff.prototype.toObject>[];
                totalBidLevels?: number;
                totalAskLevels?: number;
                totalBidOrders?: number;
                totalAskOrders?: number;
            } = {};
            if (this.diffs != null) {
                data.diffs = this.diffs.map((item: MarketByOrderDiff.Diff) => item.toObject());
            }
            if (this.totalBidLevels != null) {
                data.totalBidLevels = this.totalBidLevels;
            }
            if (this.totalAskLevels != null) {
                data.totalAskLevels = this.totalAskLevels;
            }
            if (this.totalBidOrders != null) {
                data.totalBidOrders = this.totalBidOrders;
            }
            if (this.totalAskOrders != null) {
                data.totalAskOrders = this.totalAskOrders;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.diffs.length)
                writer.writeRepeatedMessage(1, this.diffs, (item: MarketByOrderDiff.Diff) => item.serialize(writer));
            if (this.totalBidLevels != 0)
                writer.writeUint32(2, this.totalBidLevels);
            if (this.totalAskLevels != 0)
                writer.writeUint32(3, this.totalAskLevels);
            if (this.totalBidOrders != 0)
                writer.writeUint32(4, this.totalBidOrders);
            if (this.totalAskOrders != 0)
                writer.writeUint32(5, this.totalAskOrders);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MarketByOrderDiff {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MarketByOrderDiff();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.diffs, () => pb_1.Message.addToRepeatedWrapperField(message, 1, MarketByOrderDiff.Diff.deserialize(reader), MarketByOrderDiff.Diff));
                        break;
                    case 2:
                        message.totalBidLevels = reader.readUint32();
                        break;
                    case 3:
                        message.totalAskLevels = reader.readUint32();
                        break;
                    case 4:
                        message.totalBidOrders = reader.readUint32();
                        break;
                    case 5:
                        message.totalAskOrders = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MarketByOrderDiff {
            return MarketByOrderDiff.deserialize(bytes);
        }
    }
    export namespace MarketByOrderDiff {
        export enum DiffOp {
            ADD = 0,
            REMOVE = 1,
            REPLACE = 2
        }
        export class Diff extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                price?: number;
                quantity?: number;
                exchangeOrderId?: number;
                side?: Side;
                op?: MarketByOrderDiff.DiffOp;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("price" in data && data.price != undefined) {
                        this.price = data.price;
                    }
                    if ("quantity" in data && data.quantity != undefined) {
                        this.quantity = data.quantity;
                    }
                    if ("exchangeOrderId" in data && data.exchangeOrderId != undefined) {
                        this.exchangeOrderId = data.exchangeOrderId;
                    }
                    if ("side" in data && data.side != undefined) {
                        this.side = data.side;
                    }
                    if ("op" in data && data.op != undefined) {
                        this.op = data.op;
                    }
                }
            }
            get price() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set price(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get quantity() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set quantity(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get exchangeOrderId() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set exchangeOrderId(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            get side() {
                return pb_1.Message.getFieldWithDefault(this, 4, Side.BID) as Side;
            }
            set side(value: Side) {
                pb_1.Message.setField(this, 4, value);
            }
            get op() {
                return pb_1.Message.getFieldWithDefault(this, 5, MarketByOrderDiff.DiffOp.ADD) as MarketByOrderDiff.DiffOp;
            }
            set op(value: MarketByOrderDiff.DiffOp) {
                pb_1.Message.setField(this, 5, value);
            }
            static fromObject(data: {
                price?: number;
                quantity?: number;
                exchangeOrderId?: number;
                side?: Side;
                op?: MarketByOrderDiff.DiffOp;
            }): Diff {
                const message = new Diff({});
                if (data.price != null) {
                    message.price = data.price;
                }
                if (data.quantity != null) {
                    message.quantity = data.quantity;
                }
                if (data.exchangeOrderId != null) {
                    message.exchangeOrderId = data.exchangeOrderId;
                }
                if (data.side != null) {
                    message.side = data.side;
                }
                if (data.op != null) {
                    message.op = data.op;
                }
                return message;
            }
            toObject() {
                const data: {
                    price?: number;
                    quantity?: number;
                    exchangeOrderId?: number;
                    side?: Side;
                    op?: MarketByOrderDiff.DiffOp;
                } = {};
                if (this.price != null) {
                    data.price = this.price;
                }
                if (this.quantity != null) {
                    data.quantity = this.quantity;
                }
                if (this.exchangeOrderId != null) {
                    data.exchangeOrderId = this.exchangeOrderId;
                }
                if (this.side != null) {
                    data.side = this.side;
                }
                if (this.op != null) {
                    data.op = this.op;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.price != 0)
                    writer.writeUint64(1, this.price);
                if (this.quantity != 0)
                    writer.writeUint64(2, this.quantity);
                if (this.exchangeOrderId != 0)
                    writer.writeUint64(3, this.exchangeOrderId);
                if (this.side != Side.BID)
                    writer.writeEnum(4, this.side);
                if (this.op != MarketByOrderDiff.DiffOp.ADD)
                    writer.writeEnum(5, this.op);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Diff {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Diff();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.price = reader.readUint64();
                            break;
                        case 2:
                            message.quantity = reader.readUint64();
                            break;
                        case 3:
                            message.exchangeOrderId = reader.readUint64();
                            break;
                        case 4:
                            message.side = reader.readEnum();
                            break;
                        case 5:
                            message.op = reader.readEnum();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Diff {
                return Diff.deserialize(bytes);
            }
        }
    }
    export class Trades extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            trades?: Trades.Trade[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("trades" in data && data.trades != undefined) {
                    this.trades = data.trades;
                }
            }
        }
        get trades() {
            return pb_1.Message.getRepeatedWrapperField(this, Trades.Trade, 1) as Trades.Trade[];
        }
        set trades(value: Trades.Trade[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            trades?: ReturnType<typeof Trades.Trade.prototype.toObject>[];
        }): Trades {
            const message = new Trades({});
            if (data.trades != null) {
                message.trades = data.trades.map(item => Trades.Trade.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                trades?: ReturnType<typeof Trades.Trade.prototype.toObject>[];
            } = {};
            if (this.trades != null) {
                data.trades = this.trades.map((item: Trades.Trade) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.trades.length)
                writer.writeRepeatedMessage(1, this.trades, (item: Trades.Trade) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Trades {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Trades();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.trades, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Trades.Trade.deserialize(reader), Trades.Trade));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Trades {
            return Trades.deserialize(bytes);
        }
    }
    export namespace Trades {
        export class Trade extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                tradeId?: number;
                price?: number;
                aggressingSide?: Side;
                restingExchangeOrderId?: number;
                fillQuantity?: number;
                transactTime?: number;
                aggressingExchangeOrderId?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("tradeId" in data && data.tradeId != undefined) {
                        this.tradeId = data.tradeId;
                    }
                    if ("price" in data && data.price != undefined) {
                        this.price = data.price;
                    }
                    if ("aggressingSide" in data && data.aggressingSide != undefined) {
                        this.aggressingSide = data.aggressingSide;
                    }
                    if ("restingExchangeOrderId" in data && data.restingExchangeOrderId != undefined) {
                        this.restingExchangeOrderId = data.restingExchangeOrderId;
                    }
                    if ("fillQuantity" in data && data.fillQuantity != undefined) {
                        this.fillQuantity = data.fillQuantity;
                    }
                    if ("transactTime" in data && data.transactTime != undefined) {
                        this.transactTime = data.transactTime;
                    }
                    if ("aggressingExchangeOrderId" in data && data.aggressingExchangeOrderId != undefined) {
                        this.aggressingExchangeOrderId = data.aggressingExchangeOrderId;
                    }
                }
            }
            get tradeId() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set tradeId(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get price() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set price(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get aggressingSide() {
                return pb_1.Message.getFieldWithDefault(this, 3, Side.BID) as Side;
            }
            set aggressingSide(value: Side) {
                pb_1.Message.setField(this, 3, value);
            }
            get restingExchangeOrderId() {
                return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
            }
            set restingExchangeOrderId(value: number) {
                pb_1.Message.setField(this, 4, value);
            }
            get fillQuantity() {
                return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
            }
            set fillQuantity(value: number) {
                pb_1.Message.setField(this, 5, value);
            }
            get transactTime() {
                return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
            }
            set transactTime(value: number) {
                pb_1.Message.setField(this, 6, value);
            }
            get aggressingExchangeOrderId() {
                return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
            }
            set aggressingExchangeOrderId(value: number) {
                pb_1.Message.setField(this, 7, value);
            }
            static fromObject(data: {
                tradeId?: number;
                price?: number;
                aggressingSide?: Side;
                restingExchangeOrderId?: number;
                fillQuantity?: number;
                transactTime?: number;
                aggressingExchangeOrderId?: number;
            }): Trade {
                const message = new Trade({});
                if (data.tradeId != null) {
                    message.tradeId = data.tradeId;
                }
                if (data.price != null) {
                    message.price = data.price;
                }
                if (data.aggressingSide != null) {
                    message.aggressingSide = data.aggressingSide;
                }
                if (data.restingExchangeOrderId != null) {
                    message.restingExchangeOrderId = data.restingExchangeOrderId;
                }
                if (data.fillQuantity != null) {
                    message.fillQuantity = data.fillQuantity;
                }
                if (data.transactTime != null) {
                    message.transactTime = data.transactTime;
                }
                if (data.aggressingExchangeOrderId != null) {
                    message.aggressingExchangeOrderId = data.aggressingExchangeOrderId;
                }
                return message;
            }
            toObject() {
                const data: {
                    tradeId?: number;
                    price?: number;
                    aggressingSide?: Side;
                    restingExchangeOrderId?: number;
                    fillQuantity?: number;
                    transactTime?: number;
                    aggressingExchangeOrderId?: number;
                } = {};
                if (this.tradeId != null) {
                    data.tradeId = this.tradeId;
                }
                if (this.price != null) {
                    data.price = this.price;
                }
                if (this.aggressingSide != null) {
                    data.aggressingSide = this.aggressingSide;
                }
                if (this.restingExchangeOrderId != null) {
                    data.restingExchangeOrderId = this.restingExchangeOrderId;
                }
                if (this.fillQuantity != null) {
                    data.fillQuantity = this.fillQuantity;
                }
                if (this.transactTime != null) {
                    data.transactTime = this.transactTime;
                }
                if (this.aggressingExchangeOrderId != null) {
                    data.aggressingExchangeOrderId = this.aggressingExchangeOrderId;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.tradeId != 0)
                    writer.writeUint64(1, this.tradeId);
                if (this.price != 0)
                    writer.writeUint64(2, this.price);
                if (this.aggressingSide != Side.BID)
                    writer.writeEnum(3, this.aggressingSide);
                if (this.restingExchangeOrderId != 0)
                    writer.writeUint64(4, this.restingExchangeOrderId);
                if (this.fillQuantity != 0)
                    writer.writeUint64(5, this.fillQuantity);
                if (this.transactTime != 0)
                    writer.writeUint64(6, this.transactTime);
                if (this.aggressingExchangeOrderId != 0)
                    writer.writeUint64(7, this.aggressingExchangeOrderId);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Trade {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Trade();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.tradeId = reader.readUint64();
                            break;
                        case 2:
                            message.price = reader.readUint64();
                            break;
                        case 3:
                            message.aggressingSide = reader.readEnum();
                            break;
                        case 4:
                            message.restingExchangeOrderId = reader.readUint64();
                            break;
                        case 5:
                            message.fillQuantity = reader.readUint64();
                            break;
                        case 6:
                            message.transactTime = reader.readUint64();
                            break;
                        case 7:
                            message.aggressingExchangeOrderId = reader.readUint64();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Trade {
                return Trade.deserialize(bytes);
            }
        }
    }
    export class Summary extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            open?: number;
            close?: number;
            low?: number;
            high?: number;
            baseVolumeLo?: number;
            baseVolumeHi?: number;
            quoteVolumeLo?: number;
            quoteVolumeHi?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("open" in data && data.open != undefined) {
                    this.open = data.open;
                }
                if ("close" in data && data.close != undefined) {
                    this.close = data.close;
                }
                if ("low" in data && data.low != undefined) {
                    this.low = data.low;
                }
                if ("high" in data && data.high != undefined) {
                    this.high = data.high;
                }
                if ("baseVolumeLo" in data && data.baseVolumeLo != undefined) {
                    this.baseVolumeLo = data.baseVolumeLo;
                }
                if ("baseVolumeHi" in data && data.baseVolumeHi != undefined) {
                    this.baseVolumeHi = data.baseVolumeHi;
                }
                if ("quoteVolumeLo" in data && data.quoteVolumeLo != undefined) {
                    this.quoteVolumeLo = data.quoteVolumeLo;
                }
                if ("quoteVolumeHi" in data && data.quoteVolumeHi != undefined) {
                    this.quoteVolumeHi = data.quoteVolumeHi;
                }
            }
        }
        get open() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set open(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get close() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set close(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get low() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set low(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get high() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set high(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get baseVolumeLo() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set baseVolumeLo(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get baseVolumeHi() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set baseVolumeHi(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get quoteVolumeLo() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set quoteVolumeLo(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get quoteVolumeHi() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set quoteVolumeHi(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        static fromObject(data: {
            open?: number;
            close?: number;
            low?: number;
            high?: number;
            baseVolumeLo?: number;
            baseVolumeHi?: number;
            quoteVolumeLo?: number;
            quoteVolumeHi?: number;
        }): Summary {
            const message = new Summary({});
            if (data.open != null) {
                message.open = data.open;
            }
            if (data.close != null) {
                message.close = data.close;
            }
            if (data.low != null) {
                message.low = data.low;
            }
            if (data.high != null) {
                message.high = data.high;
            }
            if (data.baseVolumeLo != null) {
                message.baseVolumeLo = data.baseVolumeLo;
            }
            if (data.baseVolumeHi != null) {
                message.baseVolumeHi = data.baseVolumeHi;
            }
            if (data.quoteVolumeLo != null) {
                message.quoteVolumeLo = data.quoteVolumeLo;
            }
            if (data.quoteVolumeHi != null) {
                message.quoteVolumeHi = data.quoteVolumeHi;
            }
            return message;
        }
        toObject() {
            const data: {
                open?: number;
                close?: number;
                low?: number;
                high?: number;
                baseVolumeLo?: number;
                baseVolumeHi?: number;
                quoteVolumeLo?: number;
                quoteVolumeHi?: number;
            } = {};
            if (this.open != null) {
                data.open = this.open;
            }
            if (this.close != null) {
                data.close = this.close;
            }
            if (this.low != null) {
                data.low = this.low;
            }
            if (this.high != null) {
                data.high = this.high;
            }
            if (this.baseVolumeLo != null) {
                data.baseVolumeLo = this.baseVolumeLo;
            }
            if (this.baseVolumeHi != null) {
                data.baseVolumeHi = this.baseVolumeHi;
            }
            if (this.quoteVolumeLo != null) {
                data.quoteVolumeLo = this.quoteVolumeLo;
            }
            if (this.quoteVolumeHi != null) {
                data.quoteVolumeHi = this.quoteVolumeHi;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.open != 0)
                writer.writeUint64(1, this.open);
            if (this.close != 0)
                writer.writeUint64(2, this.close);
            if (this.low != 0)
                writer.writeUint64(3, this.low);
            if (this.high != 0)
                writer.writeUint64(4, this.high);
            if (this.baseVolumeLo != 0)
                writer.writeUint64(5, this.baseVolumeLo);
            if (this.baseVolumeHi != 0)
                writer.writeUint64(6, this.baseVolumeHi);
            if (this.quoteVolumeLo != 0)
                writer.writeUint64(7, this.quoteVolumeLo);
            if (this.quoteVolumeHi != 0)
                writer.writeUint64(8, this.quoteVolumeHi);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Summary {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Summary();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.open = reader.readUint64();
                        break;
                    case 2:
                        message.close = reader.readUint64();
                        break;
                    case 3:
                        message.low = reader.readUint64();
                        break;
                    case 4:
                        message.high = reader.readUint64();
                        break;
                    case 5:
                        message.baseVolumeLo = reader.readUint64();
                        break;
                    case 6:
                        message.baseVolumeHi = reader.readUint64();
                        break;
                    case 7:
                        message.quoteVolumeLo = reader.readUint64();
                        break;
                    case 8:
                        message.quoteVolumeHi = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Summary {
            return Summary.deserialize(bytes);
        }
    }
    export class Kline extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            interval?: KlineInterval;
            startTime?: number;
            open?: number;
            close?: number;
            high?: number;
            low?: number;
            volumeLo?: number;
            volumeHi?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("interval" in data && data.interval != undefined) {
                    this.interval = data.interval;
                }
                if ("startTime" in data && data.startTime != undefined) {
                    this.startTime = data.startTime;
                }
                if ("open" in data && data.open != undefined) {
                    this.open = data.open;
                }
                if ("close" in data && data.close != undefined) {
                    this.close = data.close;
                }
                if ("high" in data && data.high != undefined) {
                    this.high = data.high;
                }
                if ("low" in data && data.low != undefined) {
                    this.low = data.low;
                }
                if ("volumeLo" in data && data.volumeLo != undefined) {
                    this.volumeLo = data.volumeLo;
                }
                if ("volumeHi" in data && data.volumeHi != undefined) {
                    this.volumeHi = data.volumeHi;
                }
            }
        }
        get interval() {
            return pb_1.Message.getFieldWithDefault(this, 1, KlineInterval.S1) as KlineInterval;
        }
        set interval(value: KlineInterval) {
            pb_1.Message.setField(this, 1, value);
        }
        get startTime() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set startTime(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get open() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set open(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get close() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set close(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get high() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set high(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get low() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set low(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get volumeLo() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set volumeLo(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get volumeHi() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set volumeHi(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        static fromObject(data: {
            interval?: KlineInterval;
            startTime?: number;
            open?: number;
            close?: number;
            high?: number;
            low?: number;
            volumeLo?: number;
            volumeHi?: number;
        }): Kline {
            const message = new Kline({});
            if (data.interval != null) {
                message.interval = data.interval;
            }
            if (data.startTime != null) {
                message.startTime = data.startTime;
            }
            if (data.open != null) {
                message.open = data.open;
            }
            if (data.close != null) {
                message.close = data.close;
            }
            if (data.high != null) {
                message.high = data.high;
            }
            if (data.low != null) {
                message.low = data.low;
            }
            if (data.volumeLo != null) {
                message.volumeLo = data.volumeLo;
            }
            if (data.volumeHi != null) {
                message.volumeHi = data.volumeHi;
            }
            return message;
        }
        toObject() {
            const data: {
                interval?: KlineInterval;
                startTime?: number;
                open?: number;
                close?: number;
                high?: number;
                low?: number;
                volumeLo?: number;
                volumeHi?: number;
            } = {};
            if (this.interval != null) {
                data.interval = this.interval;
            }
            if (this.startTime != null) {
                data.startTime = this.startTime;
            }
            if (this.open != null) {
                data.open = this.open;
            }
            if (this.close != null) {
                data.close = this.close;
            }
            if (this.high != null) {
                data.high = this.high;
            }
            if (this.low != null) {
                data.low = this.low;
            }
            if (this.volumeLo != null) {
                data.volumeLo = this.volumeLo;
            }
            if (this.volumeHi != null) {
                data.volumeHi = this.volumeHi;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.interval != KlineInterval.S1)
                writer.writeEnum(1, this.interval);
            if (this.startTime != 0)
                writer.writeUint64(2, this.startTime);
            if (this.open != 0)
                writer.writeUint64(3, this.open);
            if (this.close != 0)
                writer.writeUint64(4, this.close);
            if (this.high != 0)
                writer.writeUint64(5, this.high);
            if (this.low != 0)
                writer.writeUint64(6, this.low);
            if (this.volumeLo != 0)
                writer.writeUint64(7, this.volumeLo);
            if (this.volumeHi != 0)
                writer.writeUint64(8, this.volumeHi);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Kline {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Kline();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.interval = reader.readEnum();
                        break;
                    case 2:
                        message.startTime = reader.readUint64();
                        break;
                    case 3:
                        message.open = reader.readUint64();
                        break;
                    case 4:
                        message.close = reader.readUint64();
                        break;
                    case 5:
                        message.high = reader.readUint64();
                        break;
                    case 6:
                        message.low = reader.readUint64();
                        break;
                    case 7:
                        message.volumeLo = reader.readUint64();
                        break;
                    case 8:
                        message.volumeHi = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Kline {
            return Kline.deserialize(bytes);
        }
    }
    export class Heartbeat extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            requestId?: number;
            timestamp?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("requestId" in data && data.requestId != undefined) {
                    this.requestId = data.requestId;
                }
                if ("timestamp" in data && data.timestamp != undefined) {
                    this.timestamp = data.timestamp;
                }
            }
        }
        get requestId() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set requestId(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get timestamp() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set timestamp(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            requestId?: number;
            timestamp?: number;
        }): Heartbeat {
            const message = new Heartbeat({});
            if (data.requestId != null) {
                message.requestId = data.requestId;
            }
            if (data.timestamp != null) {
                message.timestamp = data.timestamp;
            }
            return message;
        }
        toObject() {
            const data: {
                requestId?: number;
                timestamp?: number;
            } = {};
            if (this.requestId != null) {
                data.requestId = this.requestId;
            }
            if (this.timestamp != null) {
                data.timestamp = this.timestamp;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.requestId != 0)
                writer.writeUint64(1, this.requestId);
            if (this.timestamp != 0)
                writer.writeUint64(2, this.timestamp);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Heartbeat {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Heartbeat();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.requestId = reader.readUint64();
                        break;
                    case 2:
                        message.timestamp = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Heartbeat {
            return Heartbeat.deserialize(bytes);
        }
    }
    export class MdMessages extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            messages?: MdMessage[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("messages" in data && data.messages != undefined) {
                    this.messages = data.messages;
                }
            }
        }
        get messages() {
            return pb_1.Message.getRepeatedWrapperField(this, MdMessage, 1) as MdMessage[];
        }
        set messages(value: MdMessage[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            messages?: ReturnType<typeof MdMessage.prototype.toObject>[];
        }): MdMessages {
            const message = new MdMessages({});
            if (data.messages != null) {
                message.messages = data.messages.map(item => MdMessage.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                messages?: ReturnType<typeof MdMessage.prototype.toObject>[];
            } = {};
            if (this.messages != null) {
                data.messages = this.messages.map((item: MdMessage) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.messages.length)
                writer.writeRepeatedMessage(1, this.messages, (item: MdMessage) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MdMessages {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MdMessages();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.messages, () => pb_1.Message.addToRepeatedWrapperField(message, 1, MdMessage.deserialize(reader), MdMessage));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MdMessages {
            return MdMessages.deserialize(bytes);
        }
    }
    export class AggMessage extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3]];
        constructor(data?: any[] | ({} & (({
            heartbeat?: Heartbeat;
            topOfBooks?: never;
            rateUpdates?: never;
        } | {
            heartbeat?: never;
            topOfBooks?: TopOfBooks;
            rateUpdates?: never;
        } | {
            heartbeat?: never;
            topOfBooks?: never;
            rateUpdates?: RateUpdates;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("heartbeat" in data && data.heartbeat != undefined) {
                    this.heartbeat = data.heartbeat;
                }
                if ("topOfBooks" in data && data.topOfBooks != undefined) {
                    this.topOfBooks = data.topOfBooks;
                }
                if ("rateUpdates" in data && data.rateUpdates != undefined) {
                    this.rateUpdates = data.rateUpdates;
                }
            }
        }
        get heartbeat() {
            return pb_1.Message.getWrapperField(this, Heartbeat, 1) as Heartbeat;
        }
        set heartbeat(value: Heartbeat) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_heartbeat() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get topOfBooks() {
            return pb_1.Message.getWrapperField(this, TopOfBooks, 2) as TopOfBooks;
        }
        set topOfBooks(value: TopOfBooks) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_topOfBooks() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get rateUpdates() {
            return pb_1.Message.getWrapperField(this, RateUpdates, 3) as RateUpdates;
        }
        set rateUpdates(value: RateUpdates) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_rateUpdates() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get inner() {
            const cases: {
                [index: number]: "none" | "heartbeat" | "topOfBooks" | "rateUpdates";
            } = {
                0: "none",
                1: "heartbeat",
                2: "topOfBooks",
                3: "rateUpdates"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3])];
        }
        static fromObject(data: {
            heartbeat?: ReturnType<typeof Heartbeat.prototype.toObject>;
            topOfBooks?: ReturnType<typeof TopOfBooks.prototype.toObject>;
            rateUpdates?: ReturnType<typeof RateUpdates.prototype.toObject>;
        }): AggMessage {
            const message = new AggMessage({});
            if (data.heartbeat != null) {
                message.heartbeat = Heartbeat.fromObject(data.heartbeat);
            }
            if (data.topOfBooks != null) {
                message.topOfBooks = TopOfBooks.fromObject(data.topOfBooks);
            }
            if (data.rateUpdates != null) {
                message.rateUpdates = RateUpdates.fromObject(data.rateUpdates);
            }
            return message;
        }
        toObject() {
            const data: {
                heartbeat?: ReturnType<typeof Heartbeat.prototype.toObject>;
                topOfBooks?: ReturnType<typeof TopOfBooks.prototype.toObject>;
                rateUpdates?: ReturnType<typeof RateUpdates.prototype.toObject>;
            } = {};
            if (this.heartbeat != null) {
                data.heartbeat = this.heartbeat.toObject();
            }
            if (this.topOfBooks != null) {
                data.topOfBooks = this.topOfBooks.toObject();
            }
            if (this.rateUpdates != null) {
                data.rateUpdates = this.rateUpdates.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_heartbeat)
                writer.writeMessage(1, this.heartbeat, () => this.heartbeat.serialize(writer));
            if (this.has_topOfBooks)
                writer.writeMessage(2, this.topOfBooks, () => this.topOfBooks.serialize(writer));
            if (this.has_rateUpdates)
                writer.writeMessage(3, this.rateUpdates, () => this.rateUpdates.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AggMessage {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AggMessage();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.heartbeat, () => message.heartbeat = Heartbeat.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.topOfBooks, () => message.topOfBooks = TopOfBooks.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.rateUpdates, () => message.rateUpdates = RateUpdates.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AggMessage {
            return AggMessage.deserialize(bytes);
        }
    }
    export class TopOfBook extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            marketId?: number;
            transactTime?: number;
            bidPrice?: number;
            bidQuantity?: number;
            askPrice?: number;
            askQuantity?: number;
            lastPrice?: number;
            rolling24hPrice?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("marketId" in data && data.marketId != undefined) {
                    this.marketId = data.marketId;
                }
                if ("transactTime" in data && data.transactTime != undefined) {
                    this.transactTime = data.transactTime;
                }
                if ("bidPrice" in data && data.bidPrice != undefined) {
                    this.bidPrice = data.bidPrice;
                }
                if ("bidQuantity" in data && data.bidQuantity != undefined) {
                    this.bidQuantity = data.bidQuantity;
                }
                if ("askPrice" in data && data.askPrice != undefined) {
                    this.askPrice = data.askPrice;
                }
                if ("askQuantity" in data && data.askQuantity != undefined) {
                    this.askQuantity = data.askQuantity;
                }
                if ("lastPrice" in data && data.lastPrice != undefined) {
                    this.lastPrice = data.lastPrice;
                }
                if ("rolling24hPrice" in data && data.rolling24hPrice != undefined) {
                    this.rolling24hPrice = data.rolling24hPrice;
                }
            }
        }
        get marketId() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set marketId(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get transactTime() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set transactTime(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get bidPrice() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set bidPrice(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get bidQuantity() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set bidQuantity(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get askPrice() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set askPrice(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get askQuantity() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set askQuantity(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get lastPrice() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set lastPrice(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get rolling24hPrice() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set rolling24hPrice(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        static fromObject(data: {
            marketId?: number;
            transactTime?: number;
            bidPrice?: number;
            bidQuantity?: number;
            askPrice?: number;
            askQuantity?: number;
            lastPrice?: number;
            rolling24hPrice?: number;
        }): TopOfBook {
            const message = new TopOfBook({});
            if (data.marketId != null) {
                message.marketId = data.marketId;
            }
            if (data.transactTime != null) {
                message.transactTime = data.transactTime;
            }
            if (data.bidPrice != null) {
                message.bidPrice = data.bidPrice;
            }
            if (data.bidQuantity != null) {
                message.bidQuantity = data.bidQuantity;
            }
            if (data.askPrice != null) {
                message.askPrice = data.askPrice;
            }
            if (data.askQuantity != null) {
                message.askQuantity = data.askQuantity;
            }
            if (data.lastPrice != null) {
                message.lastPrice = data.lastPrice;
            }
            if (data.rolling24hPrice != null) {
                message.rolling24hPrice = data.rolling24hPrice;
            }
            return message;
        }
        toObject() {
            const data: {
                marketId?: number;
                transactTime?: number;
                bidPrice?: number;
                bidQuantity?: number;
                askPrice?: number;
                askQuantity?: number;
                lastPrice?: number;
                rolling24hPrice?: number;
            } = {};
            if (this.marketId != null) {
                data.marketId = this.marketId;
            }
            if (this.transactTime != null) {
                data.transactTime = this.transactTime;
            }
            if (this.bidPrice != null) {
                data.bidPrice = this.bidPrice;
            }
            if (this.bidQuantity != null) {
                data.bidQuantity = this.bidQuantity;
            }
            if (this.askPrice != null) {
                data.askPrice = this.askPrice;
            }
            if (this.askQuantity != null) {
                data.askQuantity = this.askQuantity;
            }
            if (this.lastPrice != null) {
                data.lastPrice = this.lastPrice;
            }
            if (this.rolling24hPrice != null) {
                data.rolling24hPrice = this.rolling24hPrice;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.marketId != 0)
                writer.writeUint64(1, this.marketId);
            if (this.transactTime != 0)
                writer.writeUint64(2, this.transactTime);
            if (this.bidPrice != 0)
                writer.writeUint64(3, this.bidPrice);
            if (this.bidQuantity != 0)
                writer.writeUint64(4, this.bidQuantity);
            if (this.askPrice != 0)
                writer.writeUint64(5, this.askPrice);
            if (this.askQuantity != 0)
                writer.writeUint64(6, this.askQuantity);
            if (this.lastPrice != 0)
                writer.writeUint64(7, this.lastPrice);
            if (this.rolling24hPrice != 0)
                writer.writeUint64(8, this.rolling24hPrice);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TopOfBook {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TopOfBook();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.marketId = reader.readUint64();
                        break;
                    case 2:
                        message.transactTime = reader.readUint64();
                        break;
                    case 3:
                        message.bidPrice = reader.readUint64();
                        break;
                    case 4:
                        message.bidQuantity = reader.readUint64();
                        break;
                    case 5:
                        message.askPrice = reader.readUint64();
                        break;
                    case 6:
                        message.askQuantity = reader.readUint64();
                        break;
                    case 7:
                        message.lastPrice = reader.readUint64();
                        break;
                    case 8:
                        message.rolling24hPrice = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TopOfBook {
            return TopOfBook.deserialize(bytes);
        }
    }
    export class TopOfBooks extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            tops?: TopOfBook[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tops" in data && data.tops != undefined) {
                    this.tops = data.tops;
                }
            }
        }
        get tops() {
            return pb_1.Message.getRepeatedWrapperField(this, TopOfBook, 1) as TopOfBook[];
        }
        set tops(value: TopOfBook[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            tops?: ReturnType<typeof TopOfBook.prototype.toObject>[];
        }): TopOfBooks {
            const message = new TopOfBooks({});
            if (data.tops != null) {
                message.tops = data.tops.map(item => TopOfBook.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                tops?: ReturnType<typeof TopOfBook.prototype.toObject>[];
            } = {};
            if (this.tops != null) {
                data.tops = this.tops.map((item: TopOfBook) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tops.length)
                writer.writeRepeatedMessage(1, this.tops, (item: TopOfBook) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TopOfBooks {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TopOfBooks();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.tops, () => pb_1.Message.addToRepeatedWrapperField(message, 1, TopOfBook.deserialize(reader), TopOfBook));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TopOfBooks {
            return TopOfBooks.deserialize(bytes);
        }
    }
    export class RateUpdate extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            assetId?: number;
            timestamp?: number;
            rate?: number;
            side?: RateUpdateSide;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("assetId" in data && data.assetId != undefined) {
                    this.assetId = data.assetId;
                }
                if ("timestamp" in data && data.timestamp != undefined) {
                    this.timestamp = data.timestamp;
                }
                if ("rate" in data && data.rate != undefined) {
                    this.rate = data.rate;
                }
                if ("side" in data && data.side != undefined) {
                    this.side = data.side;
                }
            }
        }
        get assetId() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set assetId(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get timestamp() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set timestamp(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get rate() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set rate(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get side() {
            return pb_1.Message.getFieldWithDefault(this, 4, RateUpdateSide.BASE) as RateUpdateSide;
        }
        set side(value: RateUpdateSide) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            assetId?: number;
            timestamp?: number;
            rate?: number;
            side?: RateUpdateSide;
        }): RateUpdate {
            const message = new RateUpdate({});
            if (data.assetId != null) {
                message.assetId = data.assetId;
            }
            if (data.timestamp != null) {
                message.timestamp = data.timestamp;
            }
            if (data.rate != null) {
                message.rate = data.rate;
            }
            if (data.side != null) {
                message.side = data.side;
            }
            return message;
        }
        toObject() {
            const data: {
                assetId?: number;
                timestamp?: number;
                rate?: number;
                side?: RateUpdateSide;
            } = {};
            if (this.assetId != null) {
                data.assetId = this.assetId;
            }
            if (this.timestamp != null) {
                data.timestamp = this.timestamp;
            }
            if (this.rate != null) {
                data.rate = this.rate;
            }
            if (this.side != null) {
                data.side = this.side;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.assetId != 0)
                writer.writeUint64(1, this.assetId);
            if (this.timestamp != 0)
                writer.writeUint64(2, this.timestamp);
            if (this.rate != 0)
                writer.writeUint64(3, this.rate);
            if (this.side != RateUpdateSide.BASE)
                writer.writeEnum(4, this.side);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RateUpdate {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RateUpdate();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.assetId = reader.readUint64();
                        break;
                    case 2:
                        message.timestamp = reader.readUint64();
                        break;
                    case 3:
                        message.rate = reader.readUint64();
                        break;
                    case 4:
                        message.side = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RateUpdate {
            return RateUpdate.deserialize(bytes);
        }
    }
    export class RateUpdates extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            updates?: RateUpdate[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("updates" in data && data.updates != undefined) {
                    this.updates = data.updates;
                }
            }
        }
        get updates() {
            return pb_1.Message.getRepeatedWrapperField(this, RateUpdate, 1) as RateUpdate[];
        }
        set updates(value: RateUpdate[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            updates?: ReturnType<typeof RateUpdate.prototype.toObject>[];
        }): RateUpdates {
            const message = new RateUpdates({});
            if (data.updates != null) {
                message.updates = data.updates.map(item => RateUpdate.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                updates?: ReturnType<typeof RateUpdate.prototype.toObject>[];
            } = {};
            if (this.updates != null) {
                data.updates = this.updates.map((item: RateUpdate) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.updates.length)
                writer.writeRepeatedMessage(1, this.updates, (item: RateUpdate) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RateUpdates {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RateUpdates();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.updates, () => pb_1.Message.addToRepeatedWrapperField(message, 1, RateUpdate.deserialize(reader), RateUpdate));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RateUpdates {
            return RateUpdates.deserialize(bytes);
        }
    }
    export class ClientMessage extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2]];
        constructor(data?: any[] | ({} & (({
            heartbeat?: Heartbeat;
            config?: never;
        } | {
            heartbeat?: never;
            config?: Config;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("heartbeat" in data && data.heartbeat != undefined) {
                    this.heartbeat = data.heartbeat;
                }
                if ("config" in data && data.config != undefined) {
                    this.config = data.config;
                }
            }
        }
        get heartbeat() {
            return pb_1.Message.getWrapperField(this, Heartbeat, 1) as Heartbeat;
        }
        set heartbeat(value: Heartbeat) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_heartbeat() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get config() {
            return pb_1.Message.getWrapperField(this, Config, 2) as Config;
        }
        set config(value: Config) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_config() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get inner() {
            const cases: {
                [index: number]: "none" | "heartbeat" | "config";
            } = {
                0: "none",
                1: "heartbeat",
                2: "config"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
        }
        static fromObject(data: {
            heartbeat?: ReturnType<typeof Heartbeat.prototype.toObject>;
            config?: ReturnType<typeof Config.prototype.toObject>;
        }): ClientMessage {
            const message = new ClientMessage({});
            if (data.heartbeat != null) {
                message.heartbeat = Heartbeat.fromObject(data.heartbeat);
            }
            if (data.config != null) {
                message.config = Config.fromObject(data.config);
            }
            return message;
        }
        toObject() {
            const data: {
                heartbeat?: ReturnType<typeof Heartbeat.prototype.toObject>;
                config?: ReturnType<typeof Config.prototype.toObject>;
            } = {};
            if (this.heartbeat != null) {
                data.heartbeat = this.heartbeat.toObject();
            }
            if (this.config != null) {
                data.config = this.config.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_heartbeat)
                writer.writeMessage(1, this.heartbeat, () => this.heartbeat.serialize(writer));
            if (this.has_config)
                writer.writeMessage(2, this.config, () => this.config.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ClientMessage {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ClientMessage();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.heartbeat, () => message.heartbeat = Heartbeat.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.config, () => message.config = Config.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ClientMessage {
            return ClientMessage.deserialize(bytes);
        }
    }
    export class Config extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            mbp?: boolean;
            mbo?: boolean;
            trades?: boolean;
            summary?: boolean;
            klines?: KlineInterval[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("mbp" in data && data.mbp != undefined) {
                    this.mbp = data.mbp;
                }
                if ("mbo" in data && data.mbo != undefined) {
                    this.mbo = data.mbo;
                }
                if ("trades" in data && data.trades != undefined) {
                    this.trades = data.trades;
                }
                if ("summary" in data && data.summary != undefined) {
                    this.summary = data.summary;
                }
                if ("klines" in data && data.klines != undefined) {
                    this.klines = data.klines;
                }
            }
        }
        get mbp() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set mbp(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get mbo() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set mbo(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        get trades() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set trades(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        get summary() {
            return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
        }
        set summary(value: boolean) {
            pb_1.Message.setField(this, 4, value);
        }
        get klines() {
            return pb_1.Message.getFieldWithDefault(this, 5, []) as KlineInterval[];
        }
        set klines(value: KlineInterval[]) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            mbp?: boolean;
            mbo?: boolean;
            trades?: boolean;
            summary?: boolean;
            klines?: KlineInterval[];
        }): Config {
            const message = new Config({});
            if (data.mbp != null) {
                message.mbp = data.mbp;
            }
            if (data.mbo != null) {
                message.mbo = data.mbo;
            }
            if (data.trades != null) {
                message.trades = data.trades;
            }
            if (data.summary != null) {
                message.summary = data.summary;
            }
            if (data.klines != null) {
                message.klines = data.klines;
            }
            return message;
        }
        toObject() {
            const data: {
                mbp?: boolean;
                mbo?: boolean;
                trades?: boolean;
                summary?: boolean;
                klines?: KlineInterval[];
            } = {};
            if (this.mbp != null) {
                data.mbp = this.mbp;
            }
            if (this.mbo != null) {
                data.mbo = this.mbo;
            }
            if (this.trades != null) {
                data.trades = this.trades;
            }
            if (this.summary != null) {
                data.summary = this.summary;
            }
            if (this.klines != null) {
                data.klines = this.klines;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.mbp != false)
                writer.writeBool(1, this.mbp);
            if (this.mbo != false)
                writer.writeBool(2, this.mbo);
            if (this.trades != false)
                writer.writeBool(3, this.trades);
            if (this.summary != false)
                writer.writeBool(4, this.summary);
            if (this.klines.length)
                writer.writePackedEnum(5, this.klines);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Config {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Config();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.mbp = reader.readBool();
                        break;
                    case 2:
                        message.mbo = reader.readBool();
                        break;
                    case 3:
                        message.trades = reader.readBool();
                        break;
                    case 4:
                        message.summary = reader.readBool();
                        break;
                    case 5:
                        message.klines = reader.readPackedEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Config {
            return Config.deserialize(bytes);
        }
    }
}